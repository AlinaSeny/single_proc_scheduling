Это средство для построения однопроцессорного расписания с минимизацией пикового использования ресурса на основе линейного программирования. 
Включает в себя транслятор графов во входной язык решателя, скрипт для запуска экспериментов, программу для сборки результатов 
и визуализаторы входных данных. 

## **Среда выполнения**

Предварительные эксперименты с решателями CBC, GLPK, SCIP проводились на компьютере со следующими характеристиками:
* ЦП: AMD Ryzen 3 5300U, тактовая частота 2.6 ГГц
* Количество ядер: 4
* Oбъем ОЗУ: 8 Гб
* OС: Ubuntu 20.04 LTS

Основная серия экспериментов с решателем SCIP проводились на компьютере со следующими характеристиками:
* ЦП: Intel Xeon E5-2650 v4 @ 2.20GHz
* Количество ядер: 20
* Oбъем ОЗУ: 64 Гб
* OС: Ubuntu 20.04 LTS

Использовались следующие версии решателей:
* SCIP 9.2.1 (скачен пресобранный)
* GLPK 5.0 (установлен из пакета)
* CBC COIN-OR 2.10.12 (скачен пресобранный)

Установлены следующие модули python:
* matplotlib  3.10.1

## **Транслятор**

Программа make_input.py считывает данные о графе и генерирует входные данные для LP-решателя в формате lp. Программа поддерживает различные 
способы упорядочения переменных и ограничений, а также позволяет настраивать параметры обработки данных.

### Использование

Программа принимает входные данные в виде файла или директории с файлами, содержащими описание графа. Каждый файл должен содержать строки, 
где каждая строка описывает узел и его связи с другими узлами. Формат строки:

`<номер узла> <вес> <номер потомка1> <номер потомка2> ...`

#### Параметры командной строки

`-i`, `--input`: Путь к входному файлу или директории с файлами. Обязательный параметр.

`-o`, `--output`: Путь к директории для сохранения выходных файлов. По умолчанию используется директория outputs/ в текущей директории.

`-tr`, `--transitive`: Флаг, указывающий на добавление транзитивных ограничений (в дополнение к ребрам A->B B->C добавляется ребро A->C).

`-r`, `--reduce`: Выбор сведения к задаче ЦЛП: new (по умолчанию) или old. old - унаследованное от старого сведения, new - с сокращенным набором переменных. 

#### Пример запуска

`python make_input.py -i input.txt -o output/ -tr -r new`

Этот вызов обработает файл input.txt, используя транзитивные отношения и метод сведения new, и сохранит результат в директорию output/.

## **Запуск решателя**

Скрипт run_scip.sh предназначен для автоматизации запуска решателя SCIP на множестве входных файлов. Он параллельно запускает 10 экземпляров решателя, с 5
разными упорядочениями при наличии или отсутствии транзитивности, и принудительно завершает выполнение всех, если хотя бы один завершился.

### Структура директорий

**Входные данные (должны находится в SCIP/SCIPOptSuite-9.2.1-Linux каталоге)**: 
* Для транслятора должны находится в директории: `~/SCIP/SCIPOptSuite-9.2.1-Linux/translator_inputs/`.
* Для решателя должны находится в директориях:
  * `~/SCIP/SCIPOptSuite-9.2.1-Linux/inputs/new_tr/order/`
  * `~/SCIP/SCIPOptSuite-9.2.1-Linux/inputs/new_no_tr/order/`

**Выходные данные**:

* Результаты сохраняются в директориях:

  * `~/SCIP/SCIPOptSuite-9.2.1-Linux/outs/new_tr/`

  * `~/SCIP/SCIPOptSuite-9.2.1-Linux/outs/new_no_tr/`

* Логи сохраняются в директориях:

  * `~/SCIP/SCIPOptSuite-9.2.1-Linux/logs/new_tr/`

  * `~/SCIP/SCIPOptSuite-9.2.1-Linux/logs/new_no_tr/`

### Параметры запуска

**SCIP-солвер**:

* Используется бинарный файл `~/SCIP/SCIPOptSuite-9.2.1-Linux/bin/scip`.

* Применяется настройка `only_time.set` с лимитом времени выполнения, по достижении которого выполнение эксперимента прекращается. Файл `only_time.set` можно 
задать в интерактивном режиме SCIP. Для этого нужно запустить SCIP и ввести команды:

  * `set limits time 3600  # Ограничение в 3600 секунд`
  * `write only_time.set  # Сохраняем настройки`

**Входные файлы**:

Каждый файл обрабатывается с различными параметрами сортировки:

* `default`: проход по строкам (имеются в виду строки входного файла с описанием
графа) сверху вниз, по вершинам в строке слева направо;

* `up_right`: проход по строкам снизу вверх, по вершинам в строке слева направо;
 
* `down_left`: проход по строкам сверху вниз, по вершинам в строке справа налево;
 
* `tiers`: строки упорядочены по возрастанию номера яруса, к которому относится
вершина, вершины одного яруса упорядочены по возрастанию номеров в первоначальном файле; в каждой строке вершины-потомки упорядочены по той же схеме;
 
* `reverse_tiers`: схема, обратная к tiers, причем ярусы отсчитываются начиная с
выходных вершин графа.

#### Пример запуска

`bash run_scip.sh`

Скрипты `run_glpk.sh` и `run_cbc.sh` запуска решателей GLPK и CBC последовательно запускают такие же экземпляры решателя.

## **Сбор результатов**

Программа get_stats_SCIP.py предназначена для сбора данных из выходных файлов, сгенерированных SCIP-солвером. Он извлекает ключевую информацию, 
такую как время выполнения, количество вершин и статус решения, и выводит её в файл SCIP_res.py.

### Как использовать

1. По умолчанию скрипт считывает выходные файлы SCIP из следующих директорий:

* `data/schedules/SCIP/outs/new_no_tr`
* `data/schedules/SCIP/outs/new_tr`

Но вы можете задать путь к директории с папками `new_no_tr` и `new_tr` в качестве параметра:

`python get_stats_SCIP.py <директория с выходными файлами SCIP>`

Скрипт запишет результаты в файл `SCIP_res.py` для каждой директории в формате:

```
times1 = {'task1': 123.45, 'task2': 67.89, ...}
nodes1 = {'task1': 10, 'task2': 20, ...}
status1 = {'task1': True, 'task2': False, ...}
```

Аналогично работают и вызываются программы `get_stats_GLPK.py` и `get_stats_CBC.py` для решателей GLPK и CBC.

## **Визуализация данных**

В каталоге со всеми программами перечисленными ниже должен находиться файл `SCIP_res.py`, сгенерированный с помощью программы `get_stats_SCIP.py`.

* Программа `show_res_SCIP.py` строит диаграммы вида `data/charts/default60`, в качестве необязательного аргумента передается название графа 
(по умолчанию `default60`). 

* Программа `show_sorts_SCIP.py` строит диаграммы сравнения упорядочений вида `data/charts/sorts` и `data/charts/sorts_tr` с отсутствием 
или наличием транзитивных ограничений. Если нужно сравнить упорядочения с транзитивностью используйте флаг `-tr`.

* Программа `plot_triang.py` строит диаграмму `data/charts/trianglog` для треугольных графов.

* Программа `plot_layered.py` строит диаграмму `data/charts/layeredlog` для слоистых графов.

* Программа `plot_dag.py` строит диаграмму `data/charts/dagpie` для случайных графов.

В каталоге с программой `show_all.py`, которая строит диаграммы `data/charts/solvers_*` должны находиться файлы `SCIP_res.py`, 
`GLPK_res.py` и `CBC_res.py`, сгенерированные с помощью программ `get_stats_SCIP.py`, `get_stats_GLPK.py` и `get_stats_CBC.py` 
соответственно. 

В каталоге с программой `show_all.py`, которая строит диаграммы `data/charts/solvers_*` должны находиться файлы `SCIP_res.py`, 
`GLPK_res.py` и `CBC_res.py`, сгенерированные с помощью программ `get_stats_SCIP.py`, `get_stats_GLPK.py` и `get_stats_CBC.py` соответственно.