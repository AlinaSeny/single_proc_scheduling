Это средство для построения однопроцессорного расписания с минимизацией пикового использования ресурса на основе линейного программирования. 
Включает в себя транслятор графов во входной язык решателя, скрипт для запуска экспериментов, программу для сборки результатов 
и визуализаторы входных данных. 

## **Среда выполнения**

Эксперименты проводились на компьютере со следующими характеристиками:
* ЦП: Intel Xeon E5-2650 v4 @ 2.20GHz
* Количество ядер: 20
* Oбъем ОЗУ: 64 Гб
* OС: Ubuntu 20.04 LTS

Использовались следующие версии решателей:
* SCIP 9.2.1 (скачен пресобранный)
* GLPK 5.0 (установлен из пакета)
* CBC COIN-OR 2.10.12 (скачен пресобранный)

Установлены следующие модули python:
* matplotlib  3.10.1

## **Транслятор**

Программа make_input.py считывает данные о графе и генерирует входные данные для LP-решателя в формате lp. Программа поддерживает различные 
способы упорядочения переменных и ограничений, а также позволяет настраивать параметры обработки данных.

### Использование

Программа принимает входные данные в виде файла или директории с файлами, содержащими описание графа. Каждый файл должен содержать строки, 
где каждая строка описывает узел и его связи с другими узлами. Формат строки:

`<номер узла> <вес> <номер потомка1> <номер потомка2> ...`

#### Параметры командной строки

`-i`, `--input`: Путь к входному файлу или директории с файлами. Обязательный параметр.

`-o`, `--output`: Путь к директории для сохранения выходных файлов. По умолчанию используется директория outputs/ в текущей директории.

`-tr`, `--transitive`: Флаг, указывающий на добавление транзитивных ограничений (в дополнение к ребрам A->B B->C добавляется ребро A->C).

`-r`, `--reduce`: Выбор сведения к задаче ЦЛП: new (по умолчанию) или old. old - унаследованное от старого сведения, new - с сокращенным набором переменных. 

#### Пример запуска

`python make_input.py -i input.txt -o output/ -tr -r new`

Этот вызов обработает файл input.txt, используя транзитивные отношения и метод сведения new, и сохранит результат в директорию output/.

## **Запуск решателя**

Скрипт run_scip.sh предназначен для автоматизации запуска решателя SCIP на множестве входных файлов. Он параллельно запускает 10 экземпляров решателя, с 5
разными упорядочениями при наличии или отсутствии транзитивности, и принудительно завершает выполнение всех, если хотя бы один завершился.

### Структура директорий

**Входные данные (должны находится в SCIP/SCIPOptSuite-9.2.1-Linux каталоге)**: 
* Для транслятора должны находится в директории: `~/SCIP/SCIPOptSuite-9.2.1-Linux/translator_inputs/`.
* Для решателя должны находится в директориях:
  * `~/SCIP/SCIPOptSuite-9.2.1-Linux/inputs/new_tr/order/`
  * `~/SCIP/SCIPOptSuite-9.2.1-Linux/inputs/new_no_tr/order/`

**Выходные данные**:

* Результаты сохраняются в директориях:

  * `~/SCIP/SCIPOptSuite-9.2.1-Linux/outs/new_tr/`

  * `~/SCIP/SCIPOptSuite-9.2.1-Linux/outs/new_no_tr/`

* Логи сохраняются в директориях:

  * `~/SCIP/SCIPOptSuite-9.2.1-Linux/logs/new_tr/`

  * `~/SCIP/SCIPOptSuite-9.2.1-Linux/logs/new_no_tr/`

### Параметры запуска

**SCIP-солвер**:

* Используется бинарный файл `~/SCIP/SCIPOptSuite-9.2.1-Linux/bin/scip`.

* Применяется настройка `only_time.set` с лимитом времени выполнения, по достижении которого выполнение эксперимента прекращается. Файл `only_time.set` можно 
задать в интерактивном режиме SCIP. Для этого нужно запустить SCIP и ввести команды:

  * `set limits time 3600  # Ограничение в 3600 секунд`
  * `write only_time.set  # Сохраняем настройки`

**Входные файлы**:

Каждый файл обрабатывается с различными параметрами сортировки:

* `default`: проход по строкам (имеются в виду строки входного файла с описанием
графа) сверху вниз, по вершинам в строке слева направо;

* `up_right`: проход по строкам снизу вверх, по вершинам в строке слева направо;
 
* `down_left`: проход по строкам сверху вниз, по вершинам в строке справа налево;
 
* `tiers`: строки упорядочены по возрастанию номера яруса, к которому относится
вершина, вершины одного яруса упорядочены по возрастанию номеров в первоначальном файле; в каждой строке вершины-потомки упорядочены по той же схеме;
 
* `reverse_tiers`: схема, обратная к tiers, причем ярусы отсчитываются начиная с
выходных вершин графа.

#### Пример запуска

`bash run_scip_solver.sh`

## **Сбор результатов**

Программа get_stats_SCIP.py предназначена для сбора данных из выходных файлов, сгенерированных SCIP-солвером. Он извлекает ключевую информацию, 
такую как время выполнения, количество узлов, статус решения и значение целевой функции, и выводит её в удобном формате.

### Как использовать

1. Убедитесь, что выходные файлы SCIP находятся в следующих директориях:

* `outs/new_no_tr`
* `outs/new_tr`
* `outs/old_tr`
* `outs/old_no_tr`

Запустите скрипт:

`python get_stats_SCIP.py`

Скрипт выведет результаты для каждой директории в формате:

```path1 = 'new_no_tr'
names1 = ['task1', 'task2', ...]
times1 = {'task1': 123.45, 'task2': 67.89, ...}
nodes1 = {'task1': 10, 'task2': 20, ...}
status1 = {'task1': True, 'task2': False, ...}
```

## **Визуализация данных**



Требования

Модули: re, os, argparse, pathlib, copy

Лицензия
Этот проект распространяется под лицензией MIT. Подробности см. в файле LICENSE.

Автор
[Алина Сенюшкина]
